# Some Assembly Required 1

## Information

- picoCTF 2021
- Web Exploitation
- 70 Points

## Description

http://mercury.picoctf.net:1896/index.html

## Hints

(None)

## Solution

Using DevTools and going onto the Sources tab reveals two files, an HTML file and a JavaScript file. The HTML file in this challenge does not contain any useful information, however, the JavaScript file seems to be obfuscated.

```js
const _0x402c = [
  "value",
  "2wfTpTR",
  "instantiate",
  "275341bEPcme",
  "innerHTML",
  "1195047NznhZg",
  "1qfevql",
  "input",
  "1699808QuoWhA",
  "Correct!",
  "check_flag",
  "Incorrect!",
  "./JIFxzHyW8W",
  "23SMpAuA",
  "802698XOMSrr",
  "charCodeAt",
  "474547vVoGDO",
  "getElementById",
  "instance",
  "copy_char",
  "43591XxcWUl",
  "504454llVtzW",
  "arrayBuffer",
  "2NIQmVj",
  "result",
];
const _0x4e0e = function (_0x553839, _0x53c021) {
  _0x553839 = _0x553839 - 0x1d6;
  let _0x402c6f = _0x402c[_0x553839];
  return _0x402c6f;
};
(function (_0x76dd13, _0x3dfcae) {
  const _0x371ac6 = _0x4e0e;
  while (!![]) {
    try {
      const _0x478583 =
        -parseInt(_0x371ac6(0x1eb)) +
        parseInt(_0x371ac6(0x1ed)) +
        -parseInt(_0x371ac6(0x1db)) * -parseInt(_0x371ac6(0x1d9)) +
        -parseInt(_0x371ac6(0x1e2)) * -parseInt(_0x371ac6(0x1e3)) +
        -parseInt(_0x371ac6(0x1de)) * parseInt(_0x371ac6(0x1e0)) +
        parseInt(_0x371ac6(0x1d8)) * parseInt(_0x371ac6(0x1ea)) +
        -parseInt(_0x371ac6(0x1e5));
      if (_0x478583 === _0x3dfcae) break;
      else _0x76dd13["push"](_0x76dd13["shift"]());
    } catch (_0x41d31a) {
      _0x76dd13["push"](_0x76dd13["shift"]());
    }
  }
})(_0x402c, 0x994c3);
let exports;
(async () => {
  const _0x48c3be = _0x4e0e;
  let _0x5f0229 = await fetch(_0x48c3be(0x1e9)),
    _0x1d99e9 = await WebAssembly[_0x48c3be(0x1df)](
      await _0x5f0229[_0x48c3be(0x1da)]()
    ),
    _0x1f8628 = _0x1d99e9[_0x48c3be(0x1d6)];
  exports = _0x1f8628["exports"];
})();
function onButtonPress() {
  const _0xa80748 = _0x4e0e;
  let _0x3761f8 = document["getElementById"](_0xa80748(0x1e4))[
    _0xa80748(0x1dd)
  ];
  for (let _0x16c626 = 0x0; _0x16c626 < _0x3761f8["length"]; _0x16c626++) {
    exports[_0xa80748(0x1d7)](
      _0x3761f8[_0xa80748(0x1ec)](_0x16c626),
      _0x16c626
    );
  }
  exports["copy_char"](0x0, _0x3761f8["length"]),
    exports[_0xa80748(0x1e7)]() == 0x1
      ? (document[_0xa80748(0x1ee)](_0xa80748(0x1dc))[_0xa80748(0x1e1)] =
          _0xa80748(0x1e6))
      : (document[_0xa80748(0x1ee)](_0xa80748(0x1dc))[_0xa80748(0x1e1)] =
          _0xa80748(0x1e8));
}
```

Therefore we need to deobfuscate it. Using and online deobfuscator or AI we can deobfuscate it to reveal the following code:

```js
let exports;

(async () => {
  let response = await fetch("./JIFxzHyW8W"),
    wasmModule = await WebAssembly.instantiate(await response.arrayBuffer()),
    instance = wasmModule.instance;
  exports = instance.exports;
})();

function onButtonPress() {
  let input = document.getElementById("input").value;

  for (let index = 0; index < input.length; index++) {
    exports.copy_char(input.charCodeAt(index), index);
  }

  exports.copy_char(0, input.length);

  exports.check_flag() == 1
    ? (document.getElementById("check_flag").innerHTML = "Correct!")
    : (document.getElementById("check_flag").innerHTML = "Incorrect!");
}
```

The JavaScript code seems to take each character of the inputted flag and submits it to a WebAssembly script `JIFxzHyW8W` and calls `check_flag()` to see if the flag is correct.

Using this link: http://mercury.picoctf.net:1896/index.html/JIFxzHyW8W gives us the WebAssembly file and opening it will reveal the flag.

## Flag

picoCTF{a2843c6ba4157dc1bc052818a6242c3f}
